[
  {
    "projectId": "21a68571-4904-43ca-b42a-d538bd7a4b2a",
    "testId": "05694e11-a4e2-4418-92f9-639399ec830b",
    "userId": "f4c8f438-d0c1-703e-e0e0-d1395049be2c",
    "title": "TC001-createpost authenticated user success",
    "description": "Test creating a new post with valid title, content, and category by an authenticated user. Verify the post is saved with correct author attribution and the response redirects to the category page.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3000/api/posts\"\nTIMEOUT = 30\n\n# Set your valid authentication token here\nAUTH_TOKEN = \"Bearer your_valid_auth_token_here\"\n\ndef test_createpost_authenticated_user_success():\n    url = f\"{BASE_URL}/createPost\"\n    headers = {\n        \"Authorization\": AUTH_TOKEN,\n    }\n    payload = {\n        \"title\": \"Test Post Title\",\n        \"content\": \"This is a test post content for authenticated user creation.\",\n        \"category\": \"general\"\n    }\n    try:\n        # Use 'files' to send multipart/form-data\n        response = requests.post(url, headers=headers, files=payload, timeout=TIMEOUT, allow_redirects=False)\n    except requests.RequestException as e:\n        assert False, f\"Request to create post failed with exception: {e}\"\n\n    # According to PRD, on success it returns HTTP 303 redirect to category page\n    assert response.status_code == 303, f\"Expected 303 redirect, got {response.status_code}\"\n\n    # The Location header should point to the category page\n    location = response.headers.get(\"Location\")\n    assert location is not None, \"Redirect location header missing\"\n    assert payload[\"category\"] in location, f\"Redirect location {location} does not contain category {payload['category']}\"\n\ntest_createpost_authenticated_user_success()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 33, in <module>\n  File \"<string>\", line 26, in test_createpost_authenticated_user_success\nAssertionError: Expected 303 redirect, got 405\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-18T10:51:33.553Z",
    "modified": "2026-01-18T10:52:23.304Z"
  },
  {
    "projectId": "21a68571-4904-43ca-b42a-d538bd7a4b2a",
    "testId": "91d68978-4ac1-424a-a326-382147802c1a",
    "userId": "f4c8f438-d0c1-703e-e0e0-d1395049be2c",
    "title": "TC002-createpost unauthenticated user error",
    "description": "Test creating a new post without authentication. Verify the system returns a 'User not authenticated' error and does not create the post.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3000/api/posts\"\nTIMEOUT = 30\n\ndef test_createpost_unauthenticated_user_error():\n    url = f\"{BASE_URL}/createPost\"\n    # Using multipart/form-data payload as per PRD schema\n    payload = {\n        \"title\": \"Test Post Unauthorized\",\n        \"content\": \"This post should not be created because the user is unauthenticated.\",\n        \"category\": \"general\"\n    }\n    try:\n        # No Authorization header included\n        response = requests.post(url, data=payload, timeout=TIMEOUT)\n    except requests.RequestException as e:\n        assert False, f\"Request failed unexpectedly: {e}\"\n\n    # The system should reject unauthenticated post creation.\n    # The PRD validation criteria: unauthenticated users receive \"User not authenticated\" error.\n    assert response.status_code != 303, \"Unauthenticated request unexpectedly succeeded.\"\n    # Try to parse error message for 'User not authenticated'\n    try:\n        content_type = response.headers.get(\"Content-Type\", \"\")\n        if \"application/json\" in content_type:\n            data = response.json()\n            error_msg = str(data.get(\"error\") or data.get(\"message\") or \"\")\n            assert \"User not authenticated\" in error_msg, f\"Unexpected error message: {error_msg}\"\n        else:\n            # If not json, check in text response\n            text = response.text\n            assert \"User not authenticated\" in text, \"Expected 'User not authenticated' error message in response text.\"\n    except Exception:\n        # If response not JSON or parsing fails, accept any error status code other than 303\n        assert response.status_code != 303, f\"Unexpected success status code: {response.status_code}\"\n\ntest_createpost_unauthenticated_user_error()\n",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-18T10:51:33.559Z",
    "modified": "2026-01-18T10:52:25.785Z"
  },
  {
    "projectId": "21a68571-4904-43ca-b42a-d538bd7a4b2a",
    "testId": "1382b2c5-9f0b-4ef2-969c-915a8946d623",
    "userId": "f4c8f438-d0c1-703e-e0e0-d1395049be2c",
    "title": "TC003-createpost validation errors for missing fields",
    "description": "Test creating a new post with missing or empty required fields (title, content, category). Verify appropriate validation errors are returned and no post is created.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3000/api/posts\"\nTIMEOUT = 30\nAUTH_TOKEN = \"Bearer your_authenticated_user_token_here\"  # Replace with valid token if available\n\ndef test_createpost_validation_errors_for_missing_fields():\n    url = f\"{BASE_URL}/createPost\"\n    headers = {\n        \"Authorization\": AUTH_TOKEN,\n    }\n\n    test_payloads = [\n        {},  # all missing\n        {\"title\": \"\", \"content\": \"Valid content\", \"category\": \"news\"},  # empty title\n        {\"title\": \"Valid title\", \"content\": \"\", \"category\": \"news\"},  # empty content\n        {\"title\": \"Valid title\", \"content\": \"Valid content\", \"category\": \"\"},  # empty category\n        {\"title\": \"Valid title\", \"content\": \"Valid content\"},  # missing category\n        {\"content\": \"Valid content\", \"category\": \"news\"},  # missing title\n        {\"title\": \"Valid title\", \"category\": \"news\"},  # missing content\n    ]\n\n    for payload in test_payloads:\n        # Prepare multipart/form-data fields as (field, (None, value)) pairs\n        # None filename to indicate form field\n        files = {}\n        for k, v in payload.items():\n            files[k] = (None, v)\n\n        # If payload is empty, send empty files {} to mimic form-data with no fields\n        try:\n            response = requests.post(url, headers=headers, files=files, timeout=TIMEOUT)\n        except requests.RequestException as e:\n            assert False, f\"Request failed with exception: {e}\"\n\n        # The API design expects a redirect on success (303), so validation errors should NOT return 303.\n        # Assuming validation errors return 400 or 422 or some client error with error message.\n        assert response.status_code != 303, f\"Unexpected success for payload: {payload}\"\n        # Expect client error status code (400 or 422), not 500 or 405\n        assert response.status_code in (400, 422), f\"Expected validation error status code (400/422), got {response.status_code}\"\n\n        # Response should contain validation error details to indicate missing/empty fields\n        try:\n            data = response.json()\n        except ValueError:\n            # If response is not JSON, fail test\n            assert False, \"Response is not JSON format when validation error expected\"\n\n        # Validate that error messages mention missing or empty required fields\n        error_fields = ['title', 'content', 'category']\n        error_found = any(field in str(data).lower() for field in error_fields)\n        assert error_found, f\"No validation error details for missing required fields in response: {data}\"\n\n\ntest_createpost_validation_errors_for_missing_fields()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 55, in <module>\n  File \"<string>\", line 40, in test_createpost_validation_errors_for_missing_fields\nAssertionError: Expected validation error status code (400/422), got 405\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-18T10:51:33.564Z",
    "modified": "2026-01-18T10:52:31.463Z"
  },
  {
    "projectId": "21a68571-4904-43ca-b42a-d538bd7a4b2a",
    "testId": "7184a440-6a8d-4b46-839a-7810e4e8bcba",
    "userId": "f4c8f438-d0c1-703e-e0e0-d1395049be2c",
    "title": "TC004-getpostsbycategory valid category success",
    "description": "Test fetching posts by a valid category. Verify the response returns a list of posts filtered by the specified category with optimized payload size.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3000/api/posts\"\nTIMEOUT = 30\n\ndef test_getpostsbycategory_valid_category_success():\n    category = \"technology\"\n\n    try:\n        # Make GET request to fetch posts by category\n        response = requests.get(\n            f\"{BASE_URL}/getPostsByCategory\",\n            params={\"category\": category},\n            timeout=TIMEOUT,\n        )\n        # Assert the response status code is 200\n        assert response.status_code == 200, f\"Expected status 200, got {response.status_code}\"\n\n        posts = response.json()\n        # Assert response is a list\n        assert isinstance(posts, list), \"Response is not a list\"\n\n        # Assert all posts have the requested category\n        for post in posts:\n            assert \"category\" in post, \"Post missing 'category' field\"\n            assert post[\"category\"] == category, f\"Post category '{post['category']}' does not match requested '{category}'\"\n\n        # Assert optimized payload size: posts contain only essential fields: id, title, category (assumption)\n        allowed_keys = {\"id\", \"title\", \"category\"}\n        for post in posts:\n            extra_keys = set(post.keys()) - allowed_keys\n            assert not extra_keys, f\"Post contains unexpected fields: {extra_keys}\"\n\n    except requests.RequestException as e:\n        assert False, f\"Request failed: {e}\"\n\ntest_getpostsbycategory_valid_category_success()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 37, in <module>\n  File \"<string>\", line 17, in test_getpostsbycategory_valid_category_success\nAssertionError: Expected status 200, got 404\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-18T10:51:33.569Z",
    "modified": "2026-01-18T10:52:05.028Z"
  },
  {
    "projectId": "21a68571-4904-43ca-b42a-d538bd7a4b2a",
    "testId": "4dd8b37c-4ce2-4c65-adc3-5646bf5736f8",
    "userId": "f4c8f438-d0c1-703e-e0e0-d1395049be2c",
    "title": "TC005-getpostbyid existing post success",
    "description": "Test fetching a post by a valid existing post ID. Verify the response returns the correct post details.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3000/api/posts\"\nTIMEOUT = 30\n\ndef test_getpostbyid_existing_post_success():\n    # First, create a post to ensure an existing post ID is available\n    create_url = f\"{BASE_URL}/createPost\"\n    delete_url = f\"{BASE_URL}/deletePost\"\n    get_url = f\"{BASE_URL}/getPostById\"\n    \n    # Authentication token placeholder (Replace with valid token if needed)\n    # For public access no token required as per PRD\n    headers = {}\n\n    # Post data for creation\n    post_data = {\n        'title': 'Test Post for GetById',\n        'content': 'This is a test post content for verifying getPostById endpoint.',\n        'category': 'Testing'\n    }\n\n    post_id = None\n    try:\n        # Create the post\n        # Use data= to send multipart/form-data fields\n        response_create = requests.post(create_url, data=post_data, headers=headers, timeout=TIMEOUT)\n        # According to PRD, on success returns HTTP 303 redirect to category page\n        assert response_create.status_code == 303, f\"Expected 303 on post creation, got {response_create.status_code}\"\n        \n        # The new post ID is not returned directly;\n        # So we need to get the posts by category to find the post and extract its id\n        # Use getPostsByCategory to find the newly created post\n        get_cat_url = f\"{BASE_URL}/getPostsByCategory\"\n        params_cat = {'category': post_data['category']}\n        response_cat = requests.get(get_cat_url, params=params_cat, timeout=TIMEOUT)\n        assert response_cat.status_code == 200, f\"Expected 200 when getting posts by category, got {response_cat.status_code}\"\n        posts = response_cat.json()\n        # Find the post by title and content matching exactly (assuming unique)\n        matching_posts = [post for post in posts if post.get('title') == post_data['title'] and post.get('content') == post_data['content']]\n        assert matching_posts, \"Created post not found in posts by category.\"\n        post_id = matching_posts[0].get('id')\n        assert post_id, \"Post ID missing in the post data.\"\n        \n        # Now call getPostById with the found post id\n        params_get = {'id': post_id}\n        response_get = requests.get(get_url, params=params_get, timeout=TIMEOUT)\n        assert response_get.status_code == 200, f\"Expected 200 fetching post by ID, got {response_get.status_code}\"\n        post_detail = response_get.json()\n        assert post_detail.get('id') == post_id, \"Post ID in response does not match requested ID.\"\n        assert post_detail.get('title') == post_data['title'], \"Post title does not match.\"\n        assert post_detail.get('content') == post_data['content'], \"Post content does not match.\"\n        assert post_detail.get('category') == post_data['category'], \"Post category does not match.\"\n    \n    finally:\n        # Cleanup: delete the created post to avoid test pollution\n        if post_id:\n            # Delete requires id and category query params and authentication (assumed no auth passes here)\n            params_delete = {'id': post_id, 'category': post_data['category']}\n            try:\n                response_delete = requests.delete(delete_url, params=params_delete, timeout=TIMEOUT)\n                # According to PRD, on success returns 200\n                assert response_delete.status_code == 200, f\"Expected 200 deleting post, got {response_delete.status_code}\"\n            except Exception:\n                pass\n\ntest_getpostbyid_existing_post_success()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 67, in <module>\n  File \"<string>\", line 29, in test_getpostbyid_existing_post_success\nAssertionError: Expected 303 on post creation, got 405\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-18T10:51:33.575Z",
    "modified": "2026-01-18T10:52:37.620Z"
  },
  {
    "projectId": "21a68571-4904-43ca-b42a-d538bd7a4b2a",
    "testId": "68be87b5-5b45-455d-a302-7a8af21ccc29",
    "userId": "f4c8f438-d0c1-703e-e0e0-d1395049be2c",
    "title": "TC006-getpostbyid non existent post returns 404",
    "description": "Test fetching a post by a non-existent post ID. Verify the system returns a 404 response and the frontend navigates to the 404 page.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3000/api/posts\"\n\ndef test_getpostbyid_nonexistent_post_returns_404():\n    non_existent_post_id = \"00000000-0000-0000-0000-000000000000\"  # UUID format, guaranteed non-existent\n\n    try:\n        response = requests.get(\n            f\"{BASE_URL}/getPostById\",\n            params={\"id\": non_existent_post_id},\n            timeout=30\n        )\n        assert response.status_code == 404, f\"Expected status code 404, got {response.status_code}\"\n        # Optional: validate error message or response content if known\n    except requests.exceptions.RequestException as e:\n        assert False, f\"Request failed: {e}\"\n\ntest_getpostbyid_nonexistent_post_returns_404()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-18T10:51:33.580Z",
    "modified": "2026-01-18T10:52:02.670Z"
  },
  {
    "projectId": "21a68571-4904-43ca-b42a-d538bd7a4b2a",
    "testId": "0a649deb-5ec1-46b5-a133-24d6b7020000",
    "userId": "f4c8f438-d0c1-703e-e0e0-d1395049be2c",
    "title": "TC007-updatepost authenticated owner success",
    "description": "Test updating an existing post by the authenticated owner with valid data. Verify the post is updated, ownership is enforced, and the response redirects to the post detail page.",
    "code": "import requests\nimport uuid\n\nBASE_URL = \"http://localhost:3000/api\"\nTIMEOUT = 30\n\n# Presumed valid authentication token of the owner user\nAUTH_TOKEN = \"Bearer example_valid_owner_jwt_token\"\n\ndef test_updatepost_authenticated_owner_success():\n    headers = {\n        \"Authorization\": AUTH_TOKEN,\n    }\n\n    # Step 1: Create a new post to update later\n    create_headers = {\n        **headers,\n        \"Content-Type\": \"multipart/form-data\"\n    }\n    create_data = {\n        \"title\": \"Original Post Title\",\n        \"content\": \"Original post content for testing update.\",\n        \"category\": \"technology\"\n    }\n    create_response = requests.post(f\"{BASE_URL}/createPost\", headers=create_headers, data=create_data, timeout=TIMEOUT)\n    assert create_response.status_code == 303, f\"Expected 303 on post creation, got {create_response.status_code}\"\n\n    # After creation, we need to get the post id - assume the system stores it in created Location URL (e.g. /posts/{id})\n    location = create_response.headers.get(\"Location\", \"\")\n    post_id = None\n    if location:\n        # Extract UUID from URL (expect something like /posts/<uuid>)\n        parts = location.rstrip('/').split('/')\n        if parts:\n            candidate = parts[-1]\n            try:\n                uuid.UUID(candidate)\n                post_id = candidate\n            except ValueError:\n                pass\n\n    assert post_id is not None, \"Failed to extract post ID from creation redirect location\"\n\n    try:\n        # Step 2: Update the post\n        update_headers = {\n            **headers,\n            \"Content-Type\": \"multipart/form-data\"\n        }\n        update_data = {\n            \"title\": \"Updated Post Title\",\n            \"content\": \"Updated post content with valid data for the authenticated owner.\",\n            \"category\": \"technology\"\n        }\n        update_params = {\"id\": post_id}\n        update_response = requests.post(f\"{BASE_URL}/updatePost\", headers=update_headers, params=update_params, data=update_data, timeout=TIMEOUT)\n\n        # Success response is 303 redirecting to the post detail page\n        assert update_response.status_code == 303, f\"Expected 303 on update, got {update_response.status_code}\"\n\n        location_update = update_response.headers.get(\"Location\", \"\")\n        assert location_update.endswith(post_id), \"Update redirect location does not point to post detail page\"\n\n        # Step 3: Fetch the post to confirm update and ownership enforcement\n        get_response = requests.get(f\"{BASE_URL}/getPostById\", params={\"id\": post_id}, timeout=TIMEOUT)\n        assert get_response.status_code == 200, f\"Expected 200 for getPostById, got {get_response.status_code}\"\n        post_data = get_response.json()\n        assert post_data.get(\"title\") == update_data[\"title\"], \"Post title was not updated correctly\"\n        assert post_data.get(\"content\") == update_data[\"content\"], \"Post content was not updated correctly\"\n        assert post_data.get(\"category\") == update_data[\"category\"], \"Post category was not updated correctly\"\n\n    finally:\n        # Cleanup: Delete the created post\n        delete_params = {\"id\": post_id, \"category\": update_data[\"category\"]}\n        delete_response = requests.delete(f\"{BASE_URL}/deletePost\", headers=headers, params=delete_params, timeout=TIMEOUT)\n        assert delete_response.status_code == 200, f\"Expected 200 on delete, got {delete_response.status_code}\"\n\ntest_updatepost_authenticated_owner_success()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 78, in <module>\n  File \"<string>\", line 26, in test_updatepost_authenticated_owner_success\nAssertionError: Expected 303 on post creation, got 500\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-18T10:51:33.585Z",
    "modified": "2026-01-18T10:52:24.309Z"
  },
  {
    "projectId": "21a68571-4904-43ca-b42a-d538bd7a4b2a",
    "testId": "544e0103-719d-45c0-b262-09a35670a63d",
    "userId": "f4c8f438-d0c1-703e-e0e0-d1395049be2c",
    "title": "TC008-updatepost non owner or unauthenticated error",
    "description": "Test updating a post by a user who is not the owner or without authentication. Verify the system denies the update with an error or no data change.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3000/api/posts\"\nTIMEOUT = 30\n\ndef test_updatepost_non_owner_or_unauthenticated_error():\n    headers_owner = {\n        \"Authorization\": \"Bearer owner-valid-token\"\n    }\n    headers_non_owner = {\n        \"Authorization\": \"Bearer non-owner-valid-token\"\n    }\n    headers_no_auth = {}\n\n    post_data_create = {\n        \"title\": \"Test Post Owner\",\n        \"content\": \"Content owned by the creator\",\n        \"category\": \"general\"\n    }\n    post_data_update = {\n        \"title\": \"Updated Title Unauthorized\",\n        \"content\": \"Updated content unauthorized\",\n        \"category\": \"general\"\n    }\n\n    post_id = None\n    try:\n        # Step 1: Create a post as owner user to get a post ID for update tests\n        create_response = requests.post(\n            f\"{BASE_URL}/createPost\",\n            headers=headers_owner,\n            files={\n                \"title\": (None, post_data_create[\"title\"]),\n                \"content\": (None, post_data_create[\"content\"]),\n                \"category\": (None, post_data_create[\"category\"])\n            },\n            timeout=TIMEOUT\n        )\n        assert create_response.status_code == 303, f\"Expected 303 on create, got {create_response.status_code}\"\n        # The post id is not returned in a body but assume we can get it by fetching posts by category and matching title\n        # Fetch posts by category to find the created post ID\n        get_response = requests.get(\n            f\"{BASE_URL}/getPostsByCategory\",\n            params={\"category\": post_data_create[\"category\"]},\n            timeout=TIMEOUT\n        )\n        assert get_response.status_code == 200, f\"Expected 200 on getPostsByCategory, got {get_response.status_code}\"\n        posts = get_response.json()\n        matching_posts = [p for p in posts if p.get(\"title\") == post_data_create[\"title\"]]\n        assert matching_posts, \"Created post not found in getPostsByCategory response\"\n        post_id = matching_posts[0].get(\"id\")\n        assert post_id, \"Post ID not found for created post\"\n\n        # Step 2: Attempt update by non-owner user (authenticated but not owner)\n        update_response_non_owner = requests.post(\n            f\"{BASE_URL}/updatePost\",\n            headers=headers_non_owner,\n            params={\"id\": post_id},\n            files={\n                \"title\": (None, post_data_update[\"title\"]),\n                \"content\": (None, post_data_update[\"content\"]),\n                \"category\": (None, post_data_update[\"category\"])\n            },\n            timeout=TIMEOUT\n        )\n        # Expect failure: Either 500 due to permission denied or error message in response\n        assert update_response_non_owner.status_code != 303, \"Non-owner update unexpectedly succeeded\"\n        assert update_response_non_owner.status_code in [403, 401, 500], f\"Unexpected status code for non-owner update: {update_response_non_owner.status_code}\"\n\n        # Step 3: Attempt update without authentication\n        update_response_no_auth = requests.post(\n            f\"{BASE_URL}/updatePost\",\n            headers=headers_no_auth,\n            params={\"id\": post_id},\n            files={\n                \"title\": (None, post_data_update[\"title\"]),\n                \"content\": (None, post_data_update[\"content\"]),\n                \"category\": (None, post_data_update[\"category\"])\n            },\n            timeout=TIMEOUT\n        )\n        # Expect failure: likely 401 Unauthorized or 500 error\n        assert update_response_no_auth.status_code != 303, \"Unauthenticated update unexpectedly succeeded\"\n        assert update_response_no_auth.status_code in [401, 403, 500], f\"Unexpected status code for unauthenticated update: {update_response_no_auth.status_code}\"\n\n        # Step 4: Confirm post data has not changed by fetching post details\n        post_detail_response = requests.get(\n            f\"{BASE_URL}/getPostById\",\n            params={\"id\": post_id},\n            timeout=TIMEOUT\n        )\n        assert post_detail_response.status_code == 200, f\"Expected 200 on getPostById, got {post_detail_response.status_code}\"\n        post_detail = post_detail_response.json()\n        assert post_detail[\"title\"] == post_data_create[\"title\"], \"Post title changed unexpectedly after unauthorized update\"\n        assert post_detail[\"content\"] == post_data_create[\"content\"], \"Post content changed unexpectedly after unauthorized update\"\n        assert post_detail[\"category\"] == post_data_create[\"category\"], \"Post category changed unexpectedly after unauthorized update\"\n\n    finally:\n        if post_id:\n            # Clean up by deleting the created post as owner\n            delete_response = requests.delete(\n                f\"{BASE_URL}/deletePost\",\n                headers=headers_owner,\n                params={\"id\": post_id, \"category\": post_data_create[\"category\"]},\n                timeout=TIMEOUT\n            )\n            assert delete_response.status_code == 200, f\"Failed to delete post in cleanup, status: {delete_response.status_code}\"\n\ntest_updatepost_non_owner_or_unauthenticated_error()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 109, in <module>\n  File \"<string>\", line 39, in test_updatepost_non_owner_or_unauthenticated_error\nAssertionError: Expected 303 on create, got 405\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-18T10:51:33.590Z",
    "modified": "2026-01-18T10:52:13.933Z"
  },
  {
    "projectId": "21a68571-4904-43ca-b42a-d538bd7a4b2a",
    "testId": "b1e25760-930c-4b88-9834-9ffcd4779046",
    "userId": "f4c8f438-d0c1-703e-e0e0-d1395049be2c",
    "title": "TC009-deletepost authenticated owner success",
    "description": "Test deleting a post by the authenticated owner with valid post ID and category. Verify the post is deleted and the response confirms deletion.",
    "code": "import requests\nimport uuid\n\nBASE_URL = \"http://localhost:3000/api/posts\"\nTIMEOUT = 30\n\n# Example authentication: Bearer token\nAUTH_TOKEN = \"Bearer your_valid_auth_token_here\"\n\ndef test_deletepost_authenticated_owner_success():\n    headers = {\n        \"Authorization\": AUTH_TOKEN,\n        \"Accept\": \"application/json\",\n    }\n    created_post_id = None\n    created_post_category = \"test-category\"\n\n    try:\n        # Step 1: Create a new post to delete\n        create_url = f\"{BASE_URL}/createPost\"\n        create_data = {\n            \"title\": \"Post to be deleted\",\n            \"content\": \"This post will be deleted by authenticated owner.\",\n            \"category\": created_post_category,\n        }\n        # Send as multipart/form-data\n        files = {k: (None, v) for k, v in create_data.items()}\n        create_response = requests.post(\n            create_url,\n            headers=headers,\n            files=files,\n            timeout=TIMEOUT,\n        )\n        assert create_response.status_code == 303, f\"Expected 303 on createPost, got {create_response.status_code}\"\n        # The API redirects to category page on success - no JSON body expected\n\n        # Step 2: Retrieve posts by category to find created post ID\n        get_by_cat_url = f\"{BASE_URL}/getPostsByCategory\"\n        params = {\"category\": created_post_category}\n        get_cat_response = requests.get(get_by_cat_url, params=params, timeout=TIMEOUT)\n        assert get_cat_response.status_code == 200, f\"Expected 200 on getPostsByCategory, got {get_cat_response.status_code}\"\n        posts = get_cat_response.json()\n        # Find post matching title\n        matching_posts = [p for p in posts if p.get(\"title\") == create_data[\"title\"]]\n        assert matching_posts, \"Created post not found in category list\"\n        created_post_id = matching_posts[0].get(\"id\")\n        assert created_post_id is not None, \"Created post does not have an ID\"\n\n        # Step 3: Delete the post by authenticated owner\n        delete_url = f\"{BASE_URL}/deletePost\"\n        delete_params = {\n            \"id\": created_post_id,\n            \"category\": created_post_category,\n        }\n        delete_response = requests.delete(\n            delete_url, headers=headers, params=delete_params, timeout=TIMEOUT\n        )\n        assert delete_response.status_code == 200, f\"Expected 200 on deletePost, got {delete_response.status_code}\"\n        # Deletion success response may not contain JSON, so just check status code\n\n        # Step 4: Confirm the post no longer exists\n        get_post_url = f\"{BASE_URL}/getPostById\"\n        get_post_params = {\"id\": created_post_id}\n        get_post_response = requests.get(get_post_url, params=get_post_params, timeout=TIMEOUT)\n        assert get_post_response.status_code == 404, \"Deleted post still accessible, expected 404\"\n\n    finally:\n        # Cleanup: Attempt to delete post if still exists (in case test failed before delete)\n        if created_post_id:\n            try:\n                requests.delete(\n                    f\"{BASE_URL}/deletePost\",\n                    headers=headers,\n                    params={\"id\": created_post_id, \"category\": created_post_category},\n                    timeout=TIMEOUT,\n                )\n            except Exception:\n                pass\n\ntest_deletepost_authenticated_owner_success()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 80, in <module>\n  File \"<string>\", line 34, in test_deletepost_authenticated_owner_success\nAssertionError: Expected 303 on createPost, got 405\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-18T10:51:33.596Z",
    "modified": "2026-01-18T10:52:42.315Z"
  },
  {
    "projectId": "21a68571-4904-43ca-b42a-d538bd7a4b2a",
    "testId": "ebce6a48-701e-4bf7-80ba-779acd8556e1",
    "userId": "f4c8f438-d0c1-703e-e0e0-d1395049be2c",
    "title": "TC010-deletepost non owner or unauthenticated error",
    "description": "Test deleting a post by a user who is not the owner or without authentication. Verify the system denies the deletion with an error and the post remains.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3000/api\"\nTIMEOUT = 30\n\ndef test_deletepost_non_owner_or_unauthenticated_error():\n    # Sample post data for creation by owner\n    create_post_data = {\n        'title': 'Test Post For Delete Ownership',\n        'content': 'Content for ownership test.',\n        'category': 'test-category'\n    }\n    # Authentication tokens (for demonstration; replace with valid tokens as needed)\n    owner_auth_headers = {\n        'Authorization': 'Bearer owner_valid_token'\n    }\n    non_owner_auth_headers = {\n        'Authorization': 'Bearer non_owner_valid_token'\n    }\n    # No auth headers for unauthenticated case\n    no_auth_headers = {}\n\n    # Step 1: Create a post as the owner (authenticated)\n    post_id = None\n    try:\n        create_response = requests.post(\n            f\"{BASE_URL}/createPost\",\n            files={key: (None, value) for key, value in create_post_data.items()},\n            headers=owner_auth_headers,\n            timeout=TIMEOUT\n        )\n        assert create_response.status_code == 303, f\"Expected 303 on create, got {create_response.status_code}\"\n        # There may not be post ID in response; fetch posts by category and find the newly created one to get ID\n        get_posts_response = requests.get(\n            f\"{BASE_URL}/getPostsByCategory\",\n            params={'category': create_post_data['category']},\n            timeout=TIMEOUT\n        )\n        assert get_posts_response.status_code == 200\n        posts = get_posts_response.json()\n        # Find the post we just created by title and content\n        matching_posts = [p for p in posts if p.get('title') == create_post_data['title'] and p.get('content') == create_post_data['content']]\n        assert matching_posts, \"Created post not found in list\"\n        post_id = matching_posts[0]['id']\n\n        # Step 2: Attempt to delete the post as a non-owner authenticated user\n        delete_response_non_owner = requests.delete(\n            f\"{BASE_URL}/deletePost\",\n            params={'id': post_id, 'category': create_post_data['category']},\n            headers=non_owner_auth_headers,\n            timeout=TIMEOUT\n        )\n        # Expect denial of deletion, likely a 500 error or an error in response body\n        assert delete_response_non_owner.status_code != 200, \"Non-owner should not be able to delete post\"\n\n        # Step 3: Attempt to delete the post unauthenticated\n        delete_response_unauth = requests.delete(\n            f\"{BASE_URL}/deletePost\",\n            params={'id': post_id, 'category': create_post_data['category']},\n            headers=no_auth_headers,\n            timeout=TIMEOUT\n        )\n        # Expect denial with error (likely 500 or other error code)\n        assert delete_response_unauth.status_code != 200, \"Unauthenticated user should not delete post\"\n\n        # Step 4: Verify the post still exists after deletion attempts\n        get_post_response = requests.get(\n            f\"{BASE_URL}/getPostById\",\n            params={'id': post_id},\n            timeout=TIMEOUT\n        )\n        assert get_post_response.status_code == 200, \"Post should still exist after failed delete attempts\"\n        post_data = get_post_response.json()\n        assert post_data.get('id') == post_id, \"Returned post ID does not match expected\"\n\n    finally:\n        # Cleanup: delete the post as owner to clean test data\n        if post_id:\n            requests.delete(\n                f\"{BASE_URL}/deletePost\",\n                params={'id': post_id, 'category': create_post_data['category']},\n                headers=owner_auth_headers,\n                timeout=TIMEOUT\n            )\n\ntest_deletepost_non_owner_or_unauthenticated_error()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 86, in <module>\n  File \"<string>\", line 32, in test_deletepost_non_owner_or_unauthenticated_error\nAssertionError: Expected 303 on create, got 500\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-18T10:51:33.602Z",
    "modified": "2026-01-18T10:52:58.650Z"
  }
]
