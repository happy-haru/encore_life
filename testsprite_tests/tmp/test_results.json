[
  {
    "projectId": "428e0ec8-d467-47b9-ad96-57e821731508",
    "testId": "eb0057ec-a869-4944-bf53-7ace97465377",
    "userId": "f4c8f438-d0c1-703e-e0e0-d1395049be2c",
    "title": "TC001-Create post successfully with valid input and authenticated user",
    "description": "Verify that an authenticated user can create a new post with valid title, content, and category, and that the author attribute is securely set on the server side.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click 로그인 (login) to authenticate user session.\n        frame = context.pages[-1]\n        # Click 로그인 (login) to start user authentication\n        elem = frame.locator('xpath=html/body/div[2]/header/div/div/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click the Kakao login button to authenticate user session.\n        frame = context.pages[-1]\n        # Click 카카오로 1초 만에 로그인 button to authenticate user session via Kakao\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input valid Kakao login credentials (email and password) and submit login form to authenticate user session.\n        frame = context.pages[-1]\n        # Input Kakao email for login\n        elem = frame.locator('xpath=html/body/div/div/div/main/article/div/div/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('testuser@example.com')\n        \n\n        # -> Input password into the password field and click the 로그인 button to submit the Kakao login form.\n        frame = context.pages[-1]\n        # Input Kakao password for login\n        elem = frame.locator('xpath=html/body/div/div/div/main/article/div/div/form/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('correct_password')\n        \n\n        frame = context.pages[-1]\n        # Click 로그인 button to submit Kakao login form\n        elem = frame.locator('xpath=html/body/div/div/div/main/article/div/div/form/div[3]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click the 로그인 button to submit the Kakao login form and authenticate user session.\n        frame = context.pages[-1]\n        # Click 로그인 button to submit Kakao login form and authenticate user session\n        elem = frame.locator('xpath=html/body/div/div/div/main/article/div/div/form/div[3]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click the 로그인 button (index 7) to submit the Kakao login form and authenticate the user session.\n        frame = context.pages[-1]\n        # Click 로그인 button to submit Kakao login form and authenticate user session\n        elem = frame.locator('xpath=html/body/div/div/div/main/article/div/div/form/div[4]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Post Creation Failed: Author Attribution Missing').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The test plan execution failed because the authenticated user could not create a new post with valid title, content, and category, or the server did not securely set the author attribute.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Authentication failed due to invalid Kakao credentials. Cannot proceed with creating a new post. Task stopped.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/f4c8f438-d0c1-703e-e0e0-d1395049be2c/1768807158004396//tmp/test_task/result.webm",
    "created": "2026-01-19T07:15:19.625Z",
    "modified": "2026-01-19T07:19:18.149Z"
  },
  {
    "projectId": "428e0ec8-d467-47b9-ad96-57e821731508",
    "testId": "276e86d6-8fba-4075-bad1-f97868a7c0ab",
    "userId": "f4c8f438-d0c1-703e-e0e0-d1395049be2c",
    "title": "TC002-Prevent post creation when unauthenticated",
    "description": "Verify that a createPost request from an unauthenticated user is blocked with the appropriate error message.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Attempt to create a post without user authentication by navigating to the community or post creation area.\n        frame = context.pages[-1]\n        # Click on '커뮤니티' (Community) to navigate to the community section where posts can be created.\n        elem = frame.locator('xpath=html/body/div[2]/header/div/nav/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on '첫 글 쓰러 가기' (Write First Post) link to attempt creating a post without authentication.\n        frame = context.pages[-1]\n        # Click on '첫 글 쓰러 가기' link to attempt to create a post without user authentication.\n        elem = frame.locator('xpath=html/body/div[2]/main/div[3]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=글을 작성하려면 로그인이 필요합니다.').first).to_be_visible(timeout=30000)\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/f4c8f438-d0c1-703e-e0e0-d1395049be2c/1768807022298197//tmp/test_task/result.webm",
    "created": "2026-01-19T07:15:19.633Z",
    "modified": "2026-01-19T07:17:02.488Z"
  },
  {
    "projectId": "428e0ec8-d467-47b9-ad96-57e821731508",
    "testId": "f661d1a4-7aa1-4e32-be27-5340c760539e",
    "userId": "f4c8f438-d0c1-703e-e0e0-d1395049be2c",
    "title": "TC003-Reject post creation with missing required fields",
    "description": "Verify that creating a post with empty title or content fields results in validation errors before database insertion.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click 로그인 (login) to authenticate user session.\n        frame = context.pages[-1]\n        # Click 로그인 (login) to authenticate user session\n        elem = frame.locator('xpath=html/body/div[2]/header/div/div/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click Kakao login button to authenticate user session.\n        frame = context.pages[-1]\n        # Click 카카오로 1초 만에 로그인 button to authenticate user session\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click Google login button to authenticate user session.\n        frame = context.pages[-1]\n        # Click Google login button to authenticate user session\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input email or phone in the Google sign-in form to continue authentication.\n        frame = context.pages[-1]\n        # Input email or phone in Google sign-in form\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[2]/c-wiz/main/div[2]/div/div/div/span/section/div/div/div/div/div/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('testuser@example.com')\n        \n\n        frame = context.pages[-1]\n        # Click Next button to proceed with Google sign-in\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[2]/c-wiz/main/div[3]/div/div/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Post Created Successfully').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError('Test case failed: Validation errors for empty title or content fields were not handled as expected during post creation.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "User authentication could not be completed due to security restrictions on external login providers (Google and Kakao). This prevents access to post creation functionality and validation testing. Reporting the issue and stopping further testing as per instructions.\nBrowser Console Logs:\n[WARNING] An iframe which has both allow-scripts and allow-same-origin for its sandbox attribute can escape its sandboxing. (at https://accounts.youtube.com/accounts/CheckConnection?pmpo=https%3A%2F%2Faccounts.google.com&v=-1455056896&timestamp=1768807009796:0:0)\n[WARNING] [GroupMarkerNotSet(crbug.com/242999)!:A0D8D700240C0000]Automatic fallback to software WebGL has been deprecated. Please use the --enable-unsafe-swiftshader flag to opt in to lower security guarantees for trusted content. (at https://accounts.google.com/v3/signin/identifier?opparams=%253Fredirect_to%253Dhttp%25253A%25252F%25252Flocalhost%25253A3000%25252Fauth%25252Fcallback&dsh=S201315%3A1768807005279322&client_id=391943505241-7lgja3pf5s4fqmcr3u6vqdmpkrled9fv.apps.googleusercontent.com&o2v=2&redirect_uri=https%3A%2F%2Fykjkmllojyyoxyxswhex.supabase.co%2Fauth%2Fv1%2Fcallback&response_type=code&scope=email+profile&service=lso&state=eyJhbGciOiJFUzI1NiIsImtpZCI6Ijk2OTQxZDNhLTc2MTItNDljMy1hNzdlLTVmYWY5ZjdlM2MxNiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE3Njg4MDczMDMsInNpdGVfdXJsIjoiaHR0cHM6Ly9lbmNvcmUtbGlmZS1xaHNxcW54NTYtcnl1aGFydXMtcHJvamVjdHMudmVyY2VsLmFwcCIsImlkIjoiMDAwMDAwMDAtMDAwMC0wMDAwLTAwMDAtMDAwMDAwMDAwMDAwIiwiZnVuY3Rpb25faG9va3MiOm51bGwsInByb3ZpZGVyIjoiZ29vZ2xlIiwicmVmZXJyZXIiOiJodHRwOi8vbG9jYWxob3N0OjMwMDAvYXV0aC9jYWxsYmFjayIsImZsb3dfc3RhdGVfaWQiOiIxYTNjNmYzOS0wOGJjLTQ2ZjYtYTFkYS1hZTAzOTZiMTZlZjkifQ.6HmzE8aSwS9Pw6RfV6ZfUoc_wXSlt3AJebcng3K96P6wZTfnodooCo16tusNzCRL-4DWveF0jcMFrWoKolh2lA&flowName=GeneralOAuthFlow&continue=https%3A%2F%2Faccounts.google.com%2Fsignin%2Foauth%2Fconsent%3Fauthuser%3Dunknown%26part%3DAJi8hAMlD5EZPIPsgyqhJLUz1FDlhaDt9e2in0h64ZYMprvg85KK1NtI-KDZsXvucyxdo_DdW3I6-o_JrWExfjYEGbS5z_yftWBdUzgJK_ekP6EozKMBG-2YvjawX64Sp7aChBdlEkiHMHIiOWpOXwnZujHwKWp28hX7KiaeIHyA9xMzORKd5Rg4DAE6KWaQ4Q-AN3MNuUoVlE1Ie4FMvd2q-eTb0v245LcITvfgbGw-fxDyrY8nZTAiBuI2VcPio7faLvcex7xMKwOqvGWNsG2B3nKnxhzbLUPZlq0hODlR87bzs4AS4SUM0-p5kULwJsPLv0RzHTyo_Dd11mPDUJxTOwcJzt_knF5vlqJkrErgyYsLs9UvFZHi4qXi0oRgCw9SgBDG0uVm-d_rdZm5liHuOHyiT2yBbE7HUydZPz1vqB78rAQxyHZ46wxdFe7eYRqvmBshxyCkUkCYc96XKEl09nUbRWilZxRyh7PLvosdfEWEJenMnaQ%26flowName%3DGeneralOAuthFlow%26as%3DS201315%253A1768807005279322%26client_id%3D391943505241-7lgja3pf5s4fqmcr3u6vqdmpkrled9fv.apps.googleusercontent.com%26requestPath%3D%252Fsignin%252Foauth%252Fconsent%23&app_domain=https%3A%2F%2Fykjkmllojyyoxyxswhex.supabase.co&rart=ANgoxcdkceIq0T1BrVkZtoJAE-qqV12pEqelzD7SROfbGH6Krcum2kpZhtM2w9MZ8qHSCOJCp_BbznY_qjAfJxv37Vpl0pqIELIHq43ztOLSgB5iTgr_vQc:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/f4c8f438-d0c1-703e-e0e0-d1395049be2c/1768807118134082//tmp/test_task/result.webm",
    "created": "2026-01-19T07:15:19.641Z",
    "modified": "2026-01-19T07:18:38.346Z"
  },
  {
    "projectId": "428e0ec8-d467-47b9-ad96-57e821731508",
    "testId": "4bcd1597-16e7-4120-bbd3-cc111f26513c",
    "userId": "f4c8f438-d0c1-703e-e0e0-d1395049be2c",
    "title": "TC004-Reject post creation with unknown category",
    "description": "Verify that post creation with a category not recognized by validation rules is rejected or ignored according to system design.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click on 로그인 (login) to authenticate user session.\n        frame = context.pages[-1]\n        # Click 로그인 (login) to authenticate user session\n        elem = frame.locator('xpath=html/body/div[2]/header/div/div/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click the Kakao login button to authenticate user session.\n        frame = context.pages[-1]\n        # Click 카카오로 1초 만에 로그인 button to authenticate user session via Kakao\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input dummy or test credentials into Kakao login form fields to simulate authentication or proceed with next step.\n        frame = context.pages[-1]\n        # Input test email into Kakao login ID field\n        elem = frame.locator('xpath=html/body/div/div/div/main/article/div/div/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('testuser@example.com')\n        \n\n        # -> Input test password into the password field and click the 로그인 button to attempt login.\n        frame = context.pages[-1]\n        # Input test password into Kakao login password field\n        elem = frame.locator('xpath=html/body/div/div/div/main/article/div/div/form/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('testpassword')\n        \n\n        frame = context.pages[-1]\n        # Click 로그인 button to submit Kakao login form and attempt authentication\n        elem = frame.locator('xpath=html/body/div/div/div/main/article/div/div/form/div[3]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Identify and click the correct 로그인 (Login) button on the Kakao login page to authenticate user session.\n        frame = context.pages[-1]\n        # Click 로그인 link/button to submit the Kakao login form and attempt authentication\n        elem = frame.locator('xpath=html/body/div/div/div/main/article/div/div/form/div[3]/div/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Post created successfully with invalid category').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test failed: Post creation with an invalid or unknown category was not accepted as expected. Validation error or rejection response was not observed as per the test plan.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Stopped testing due to inability to authenticate user session via Kakao login. The Kakao login button leads to a help page instead of the login form, blocking further test steps. Reporting this as a website issue.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/f4c8f438-d0c1-703e-e0e0-d1395049be2c/1768807148942604//tmp/test_task/result.webm",
    "created": "2026-01-19T07:15:19.646Z",
    "modified": "2026-01-19T07:19:09.095Z"
  },
  {
    "projectId": "428e0ec8-d467-47b9-ad96-57e821731508",
    "testId": "b29dd5da-cadf-4d85-b124-908e49da9440",
    "userId": "f4c8f438-d0c1-703e-e0e0-d1395049be2c",
    "title": "TC005-Fetch posts filtered by valid category",
    "description": "Verify that public users can fetch lists of posts filtered by a valid category, and that response payload excludes unnecessary fields to optimize performance.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Send getPostsByCategory request with a valid category parameter to verify response and payload optimization.\n        await page.goto('http://localhost:3000/api/posts?category=채용공고', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Send getPostsByCategory request with another valid category expected to have posts, to verify filtering and payload optimization.\n        await page.goto('http://localhost:3000/api/posts?category=공지사항', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Try to identify and test with another valid category that has posts to verify filtering and payload optimization.\n        await page.goto('http://localhost:3000/api/posts?category=이벤트', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=').first).to_be_visible(timeout=30000)\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/f4c8f438-d0c1-703e-e0e0-d1395049be2c/1768806988429402//tmp/test_task/result.webm",
    "created": "2026-01-19T07:15:19.653Z",
    "modified": "2026-01-19T07:16:28.550Z"
  },
  {
    "projectId": "428e0ec8-d467-47b9-ad96-57e821731508",
    "testId": "ea9aba7c-2593-4436-b83c-dc1f2c7b6f33",
    "userId": "f4c8f438-d0c1-703e-e0e0-d1395049be2c",
    "title": "TC006-Handle fetch posts by category with unknown category",
    "description": "Verify that fetching posts by an unknown category either returns empty results or returns an error according to design.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Send getPostsByCategory request with an invalid category parameter to verify response.\n        await page.goto('http://localhost:3000/api/posts?category=invalidCategory', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=').first).to_be_visible(timeout=30000)\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/f4c8f438-d0c1-703e-e0e0-d1395049be2c/1768806959697761//tmp/test_task/result.webm",
    "created": "2026-01-19T07:15:19.659Z",
    "modified": "2026-01-19T07:15:59.832Z"
  },
  {
    "projectId": "428e0ec8-d467-47b9-ad96-57e821731508",
    "testId": "81f44178-4542-4e38-98c1-774b197a358b",
    "userId": "f4c8f438-d0c1-703e-e0e0-d1395049be2c",
    "title": "TC007-Fetch individual post details by valid ID",
    "description": "Verify that public users can fetch details of an existing post given a valid post ID, and verify details are current and accurate.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Find or navigate to a page or API endpoint where a valid post ID can be used to fetch post details.\n        frame = context.pages[-1]\n        # Click on '커뮤니티' (Community) link to find posts or posts list to get a valid post ID\n        elem = frame.locator('xpath=html/body/div[2]/header/div/nav/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on a community category or topic link to access posts and obtain a valid post ID.\n        frame = context.pages[-1]\n        # Click on '재취업 성공 스토리' (Reemployment Success Story) category to find posts and post IDs\n        elem = frame.locator('xpath=html/body/div[2]/main/div[2]/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on the visible post link to open the post details page and verify the post details.\n        frame = context.pages[-1]\n        # Click on the post link with title and author to open post details\n        elem = frame.locator('xpath=html/body/div[2]/main/div/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Verify the extracted post details against expected or backend data to confirm accuracy and currency.\n        await page.goto('http://localhost:3000/api/posts/aed5c65e-3d97-40b8-bc2e-d1b0a8eb5c9d', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=ㅁㄴㅇㅁㄴ').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=ㅁㄴㅇㅁㄴㅇ').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=success-stories').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=RYU').first).to_be_visible(timeout=30000)\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/f4c8f438-d0c1-703e-e0e0-d1395049be2c/1768807078911537//tmp/test_task/result.webm",
    "created": "2026-01-19T07:15:19.665Z",
    "modified": "2026-01-19T07:17:59.091Z"
  },
  {
    "projectId": "428e0ec8-d467-47b9-ad96-57e821731508",
    "testId": "65dd95e7-04ab-4c8e-9d67-0d1c96dfec43",
    "userId": "f4c8f438-d0c1-703e-e0e0-d1395049be2c",
    "title": "TC008-Handle getPostById with non-existent post ID",
    "description": "Verify that request to getPostById with a UUID that does not exist gracefully results in frontend navigation to 404 page.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Trigger getPostById request with a non-existent UUID to check 404 response and frontend redirect.\n        await page.goto('http://localhost:3000/post/00000000-0000-0000-0000-000000000000', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=404').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=This page could not be found.').first).to_be_visible(timeout=30000)\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/f4c8f438-d0c1-703e-e0e0-d1395049be2c/176880696507235//tmp/test_task/result.webm",
    "created": "2026-01-19T07:15:19.671Z",
    "modified": "2026-01-19T07:16:05.194Z"
  },
  {
    "projectId": "428e0ec8-d467-47b9-ad96-57e821731508",
    "testId": "2125a188-50eb-43da-afbc-c870d4497a5d",
    "userId": "f4c8f438-d0c1-703e-e0e0-d1395049be2c",
    "title": "TC009-Successful update of post by authenticated owner",
    "description": "Verify an authenticated user can update their own post fields (title, content, category) successfully with changes persisted and reflected in the UI.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click on 로그인 (login) to authenticate user session owning the post.\n        frame = context.pages[-1]\n        # Click 로그인 (login) to authenticate user session owning the post\n        elem = frame.locator('xpath=html/body/div[2]/header/div/div/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click the Kakao login button to authenticate user session owning the post.\n        frame = context.pages[-1]\n        # Click 카카오로 1초 만에 로그인 (Kakao login button) to authenticate user session\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input Kakao login ID and password, then click 로그인 (login) button to authenticate user session.\n        frame = context.pages[-1]\n        # Input Kakao login ID\n        elem = frame.locator('xpath=html/body/div/div/div/main/article/div/div/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('testuser@example.com')\n        \n\n        # -> Click 로그인 (login) button to submit Kakao login form and authenticate user session.\n        frame = context.pages[-1]\n        # Click 로그인 (login) button to submit Kakao login form\n        elem = frame.locator('xpath=html/body/div/div/div/main/article/div/div/form/div[4]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input password into password field and click 로그인 (login) button to authenticate user session.\n        frame = context.pages[-1]\n        # Input Kakao login password\n        elem = frame.locator('xpath=html/body/div/div/div/main/article/div/div/form/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('TestPassword123')\n        \n\n        frame = context.pages[-1]\n        # Click 로그인 (login) button to submit Kakao login form after entering password\n        elem = frame.locator('xpath=html/body/div/div/div/main/article/div/div/form/div[4]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Post update successful and changes reflected in UI').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError('Test case failed: The authenticated user was unable to update their own post fields successfully, or the changes were not persisted and reflected in the UI as expected.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The user was unable to authenticate via Kakao login due to incorrect credentials, preventing the update of their own post fields. The issue with authentication has been reported. Task is now complete with failure to update post due to authentication failure.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/f4c8f438-d0c1-703e-e0e0-d1395049be2c/1768807109727415//tmp/test_task/result.webm",
    "created": "2026-01-19T07:15:19.677Z",
    "modified": "2026-01-19T07:18:29.859Z"
  },
  {
    "projectId": "428e0ec8-d467-47b9-ad96-57e821731508",
    "testId": "231dc9d0-c39c-4db4-8334-fec410398145",
    "userId": "f4c8f438-d0c1-703e-e0e0-d1395049be2c",
    "title": "TC010-Fail update post by non-owner due to RLS permission denial",
    "description": "Verify that attempts to update a post by a user who does not own it are rejected with error or result in no data changes due to Row Level Security enforcement.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click on 로그인 (login) to authenticate as a different user.\n        frame = context.pages[-1]\n        # Click 로그인 to start authentication as a different user\n        elem = frame.locator('xpath=html/body/div[2]/header/div/div/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click the Kakao login button to authenticate.\n        frame = context.pages[-1]\n        # Click 카카오로 1초 만에 로그인 button to authenticate user via Kakao\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input test user ID and password to authenticate.\n        frame = context.pages[-1]\n        # Input test user ID (email)\n        elem = frame.locator('xpath=html/body/div/div/div/main/article/div/div/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('testuser@example.com')\n        \n\n        # -> Input password and click 로그인 button to authenticate.\n        frame = context.pages[-1]\n        # Input test user password\n        elem = frame.locator('xpath=html/body/div/div/div/main/article/div/div/form/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('testpassword')\n        \n\n        frame = context.pages[-1]\n        # Click 로그인 button to submit Kakao login form\n        elem = frame.locator('xpath=html/body/div/div/div/main/article/div/div/form/div[3]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Post update successful').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test failed: Update attempt by non-owner user should be rejected due to Row Level Security enforcement, but 'Post update successful' message was not found as expected.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Testing stopped due to login button malfunction on Kakao login page preventing authentication as a different user. Cannot proceed with RLS enforcement test on post update.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/f4c8f438-d0c1-703e-e0e0-d1395049be2c/1768807082690128//tmp/test_task/result.webm",
    "created": "2026-01-19T07:15:19.683Z",
    "modified": "2026-01-19T07:18:02.825Z"
  },
  {
    "projectId": "428e0ec8-d467-47b9-ad96-57e821731508",
    "testId": "a0aa6953-87d4-4f7f-ae6f-f3823097c087",
    "userId": "f4c8f438-d0c1-703e-e0e0-d1395049be2c",
    "title": "TC011-Fail update post with invalid input data",
    "description": "Verify that updating a post with invalid or empty required fields returns validation errors before database update.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Authenticate user session owning the post\n        frame = context.pages[-1]\n        # Click 로그인 (Login) to authenticate user session owning the post\n        elem = frame.locator('xpath=html/body/div[2]/header/div/div/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click Kakao login button to authenticate user session owning the post\n        frame = context.pages[-1]\n        # Click 카카오로 1초 만에 로그인 (Kakao login button) to authenticate user session owning the post\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Retry authentication or proceed with alternative login method\n        frame = context.pages[-1]\n        # Click 로그인 (Login) button to attempt login or proceed with authentication\n        elem = frame.locator('xpath=html/body/div/div/div/main/article/div/div/form/div[4]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input Kakao login ID and password, then click 로그인 (login) button to authenticate user session\n        frame = context.pages[-1]\n        # Input Kakao login ID (email)\n        elem = frame.locator('xpath=html/body/div/div/div/main/article/div/div/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('testuser@example.com')\n        \n\n        # -> Input Kakao login password and click 로그인 (login) button to authenticate user session\n        frame = context.pages[-1]\n        # Input Kakao login password\n        elem = frame.locator('xpath=html/body/div/div/div/main/article/div/div/form/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('testpassword')\n        \n\n        frame = context.pages[-1]\n        # Click 로그인 (login) button to submit Kakao login form\n        elem = frame.locator('xpath=html/body/div/div/div/main/article/div/div/form/div[3]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click 로그인 (login) button to submit Kakao login form and authenticate user session\n        frame = context.pages[-1]\n        # Click 로그인 (login) button to submit Kakao login form and authenticate user session\n        elem = frame.locator('xpath=html/body/div/div/div/main/article/div/div/form/div[3]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click the correct '로그인' (Login) button to submit the Kakao login form and authenticate user session\n        frame = context.pages[-1]\n        # Click '로그인' (Login) button to submit Kakao login form and authenticate user session\n        elem = frame.locator('xpath=html/body/div/div/div/main/article/div/div/form/div[4]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Post updated successfully').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: Updating a post with invalid or empty required fields did not return validation errors as expected before database update.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Authentication failed due to invalid Kakao credentials. Cannot proceed with testing updatePost validation errors without a valid authenticated user session. Please provide valid credentials or an alternative authentication method to continue.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/f4c8f438-d0c1-703e-e0e0-d1395049be2c/1768807171735511//tmp/test_task/result.webm",
    "created": "2026-01-19T07:15:19.689Z",
    "modified": "2026-01-19T07:19:31.864Z"
  },
  {
    "projectId": "428e0ec8-d467-47b9-ad96-57e821731508",
    "testId": "4d7ea4b6-2cf9-4339-8957-26744a92e12f",
    "userId": "f4c8f438-d0c1-703e-e0e0-d1395049be2c",
    "title": "TC012-Successful deletion of post by authenticated owner",
    "description": "Verify that an authenticated owner can delete their post successfully and that the deletion is reflected on UI via updated post lists.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click 로그인 (login) to authenticate user session owning the post.\n        frame = context.pages[-1]\n        # Click 로그인 (login) to authenticate user session owning the post\n        elem = frame.locator('xpath=html/body/div[2]/header/div/div/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click the Kakao login button to authenticate user session owning the post.\n        frame = context.pages[-1]\n        # Click 카카오로 1초 만에 로그인 (Kakao login button) to authenticate user session\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input login ID and password to authenticate user session.\n        frame = context.pages[-1]\n        # Input Kakao login ID (email)\n        elem = frame.locator('xpath=html/body/div/div/div/main/article/div/div/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('testuser@example.com')\n        \n\n        # -> Input password into the password field and click 로그인 (login) button to authenticate user session.\n        frame = context.pages[-1]\n        # Input Kakao login password\n        elem = frame.locator('xpath=html/body/div/div/div/main/article/div/div/form/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('testpassword')\n        \n\n        frame = context.pages[-1]\n        # Click 로그인 (login) button to submit credentials and authenticate\n        elem = frame.locator('xpath=html/body/div/div/div/main/article/div/div/form/div[3]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click the correct 로그인 (login) button to submit credentials and authenticate user session.\n        frame = context.pages[-1]\n        # Click 로그인 (login) link to submit credentials and authenticate user session\n        elem = frame.locator('xpath=html/body/div/div/div/main/article/div/div/form/div[3]/div/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Post deletion successful!')).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The authenticated owner could not delete their post successfully or the deletion is not reflected in the UI as expected.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Stopped testing due to inability to authenticate user session. The login button is not functioning as expected, causing misclicks on the help button and blocking progress on post deletion verification.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/f4c8f438-d0c1-703e-e0e0-d1395049be2c/176880715534387//tmp/test_task/result.webm",
    "created": "2026-01-19T07:15:19.700Z",
    "modified": "2026-01-19T07:19:15.504Z"
  },
  {
    "projectId": "428e0ec8-d467-47b9-ad96-57e821731508",
    "testId": "9a37ac45-7963-4004-b2e9-25e8264bf759",
    "userId": "f4c8f438-d0c1-703e-e0e0-d1395049be2c",
    "title": "TC013-Prevent deletion of post by non-owner due to RLS",
    "description": "Verify that an authenticated user who does not own the post cannot delete it, and receives appropriate error or no data deletion occurs due to Row Level Security.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click on 로그인 (login) to authenticate as a user who does not own the post.\n        frame = context.pages[-1]\n        # Click 로그인 (login) to start authentication for non-owner user\n        elem = frame.locator('xpath=html/body/div[2]/header/div/div/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click the Kakao login button to authenticate user session who is not owner.\n        frame = context.pages[-1]\n        # Click 카카오로 1초 만에 로그인 button to authenticate user session who is not owner\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input Kakao email and password to authenticate user session who is not owner.\n        frame = context.pages[-1]\n        # Input Kakao email for non-owner user login\n        elem = frame.locator('xpath=html/body/div/div/div/main/article/div/div/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('testuser@example.com')\n        \n\n        # -> Input password into password field and click 로그인 button to authenticate user session who is not owner.\n        frame = context.pages[-1]\n        # Input Kakao password for non-owner user login\n        elem = frame.locator('xpath=html/body/div/div/div/main/article/div/div/form/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('testpassword')\n        \n\n        frame = context.pages[-1]\n        # Click 로그인 button to submit Kakao login form and authenticate user session\n        elem = frame.locator('xpath=html/body/div/div/div/main/article/div/div/form/div[3]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click the 로그인 button to submit Kakao login form and authenticate user session who is not owner.\n        frame = context.pages[-1]\n        # Click 로그인 button to submit Kakao login form and authenticate user session who is not owner\n        elem = frame.locator('xpath=html/body/div/div/div/main/article/div/div/form/div[3]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click the '로그인' button (index 7) to submit the Kakao login form and authenticate user session who is not owner.\n        frame = context.pages[-1]\n        # Click '로그인' button to submit Kakao login form and authenticate user session who is not owner\n        elem = frame.locator('xpath=html/body/div/div/div/main/article/div/div/form/div[4]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Post deleted successfully').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError('Test failed: Authenticated user who does not own the post should not be able to delete it. The post deletion was incorrectly allowed or no proper error message was shown.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Login attempt failed due to incorrect Kakao credentials. Cannot authenticate user session who is not owner. Therefore, unable to proceed with deletePost permission test. Task stopped.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/f4c8f438-d0c1-703e-e0e0-d1395049be2c/1768807152344914//tmp/test_task/result.webm",
    "created": "2026-01-19T07:15:19.707Z",
    "modified": "2026-01-19T07:19:12.489Z"
  },
  {
    "projectId": "428e0ec8-d467-47b9-ad96-57e821731508",
    "testId": "f3fc331f-b62d-44d1-beab-ee4de356ebd0",
    "userId": "f4c8f438-d0c1-703e-e0e0-d1395049be2c",
    "title": "TC014-Handle deletion of non-existent post gracefully",
    "description": "Verify that deletePost requests for a post ID that does not exist return appropriate error messages and do not cause unintended effects.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click on 로그인 (login) link to authenticate user session.\n        frame = context.pages[-1]\n        # Click on 로그인 (login) link to authenticate user session\n        elem = frame.locator('xpath=html/body/div[2]/header/div/div/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on the Kakao login button to trigger the InAppBrowserWarning component logic.\n        frame = context.pages[-1]\n        # Click on 카카오로 1초 만에 로그인 button to trigger Kakao login and InAppBrowserWarning component logic\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Authenticate user session by clicking the Kakao login button to trigger the InAppBrowserWarning component logic.\n        frame = context.pages[-1]\n        # Click on 카카오로 1초 만에 로그인 button to authenticate user session and trigger InAppBrowserWarning component logic\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Send deletePost request with a non-existent post ID and verify the error response.\n        await page.goto('http://localhost:3000/api/posts/delete', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=Post not found').first).to_be_visible(timeout=30000)\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/f4c8f438-d0c1-703e-e0e0-d1395049be2c/1768807077501894//tmp/test_task/result.webm",
    "created": "2026-01-19T07:15:19.713Z",
    "modified": "2026-01-19T07:17:57.636Z"
  },
  {
    "projectId": "428e0ec8-d467-47b9-ad96-57e821731508",
    "testId": "1a4c2d19-1f97-4eae-aa43-12b3dfdf7112",
    "userId": "f4c8f438-d0c1-703e-e0e0-d1395049be2c",
    "title": "TC015-Cache invalidation and revalidation after post creation",
    "description": "Verify that after successful creation of a post, the community listing and detail pages revalidate data so UI reflects new posts immediately.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Navigate to 로그인 (login) page to authenticate user for post creation.\n        frame = context.pages[-1]\n        # Click on 로그인 (login) link to go to login page for authentication.\n        elem = frame.locator('xpath=html/body/div[2]/header/div/div/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click the Kakao login button to authenticate user.\n        frame = context.pages[-1]\n        # Click the 카카오로 1초 만에 로그인 button to initiate Kakao login.\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input Kakao login credentials and submit to authenticate user.\n        frame = context.pages[-1]\n        # Input Kakao email ID for login.\n        elem = frame.locator('xpath=html/body/div/div/div/main/article/div/div/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('testuser@example.com')\n        \n\n        # -> Input password and click 로그인 button to submit Kakao login form.\n        frame = context.pages[-1]\n        # Input Kakao password for login.\n        elem = frame.locator('xpath=html/body/div/div/div/main/article/div/div/form/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('testpassword')\n        \n\n        frame = context.pages[-1]\n        # Click 로그인 button to submit Kakao login form.\n        elem = frame.locator('xpath=html/body/div/div/div/main/article/div/div/form/div[3]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click the correct 로그인 button to submit the Kakao login form and authenticate user.\n        frame = context.pages[-1]\n        # Click the 로그인 button link to submit Kakao login form and authenticate user.\n        elem = frame.locator('xpath=html/body/div/div/div/main/article/div/div/form/div[3]/div/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Post Creation Successful!').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The test plan execution failed to verify that after successful creation of a post, the community listing and detail pages revalidate data so UI reflects new posts immediately.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The task to verify post creation and cache revalidation could not be completed because the Kakao login form's 로그인 button opens a help page instead of submitting the form, preventing user authentication. This blocks the ability to create a post and verify cache invalidation on community listing and detail pages. The issue has been reported. Task stopped.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/f4c8f438-d0c1-703e-e0e0-d1395049be2c/1768807135610598//tmp/test_task/result.webm",
    "created": "2026-01-19T07:15:19.721Z",
    "modified": "2026-01-19T07:18:55.755Z"
  },
  {
    "projectId": "428e0ec8-d467-47b9-ad96-57e821731508",
    "testId": "b0812b50-edf7-4a02-aa03-e6e2608c2fd0",
    "userId": "f4c8f438-d0c1-703e-e0e0-d1395049be2c",
    "title": "TC016-Cache invalidation and revalidation after post update",
    "description": "Verify that after a post update, related pages revalidate content to immediately reflect updated data in the UI.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click 로그인 (login) to authenticate as post owner.\n        frame = context.pages[-1]\n        # Click 로그인 (login) to authenticate as post owner\n        elem = frame.locator('xpath=html/body/div[2]/header/div/div/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click the Kakao login button to authenticate.\n        frame = context.pages[-1]\n        # Click 카카오로 1초 만에 로그인 (Kakao login button) to authenticate as post owner\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input Kakao login credentials (ID and password) and submit login form to authenticate.\n        frame = context.pages[-1]\n        # Input Kakao login ID/email\n        elem = frame.locator('xpath=html/body/div/div/div/main/article/div/div/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('testuser@example.com')\n        \n\n        # -> Input password into the password field and click 로그인 (login) button to authenticate.\n        frame = context.pages[-1]\n        # Input Kakao login password\n        elem = frame.locator('xpath=html/body/div/div/div/main/article/div/div/form/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('testpassword')\n        \n\n        frame = context.pages[-1]\n        # Click 로그인 (login) button to submit Kakao login form\n        elem = frame.locator('xpath=html/body/div/div/div/main/article/div/div/form/div[3]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click the 로그인 (login) button to submit the login form and authenticate.\n        frame = context.pages[-1]\n        # Close the 도움말 보기 tooltip if possible\n        elem = frame.locator('xpath=html/body/div/div/div/main/article/div/div/form/div[3]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        frame = context.pages[-1]\n        # Click 로그인 (login) button to submit Kakao login form\n        elem = frame.locator('xpath=html/body/div/div/div/main/article/div/div/form/div[4]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Post update successful and cache invalidated')).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test failed: The post update did not trigger cache invalidation or the updated post data is not immediately reflected in the UI as required by the test plan.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Test stopped due to inability to authenticate as post owner. The Kakao login credentials provided are incorrect or not accepted, preventing further test steps for post update and cache invalidation verification.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/f4c8f438-d0c1-703e-e0e0-d1395049be2c/1768807120122689//tmp/test_task/result.webm",
    "created": "2026-01-19T07:15:19.727Z",
    "modified": "2026-01-19T07:18:40.270Z"
  },
  {
    "projectId": "428e0ec8-d467-47b9-ad96-57e821731508",
    "testId": "91471e4f-f862-4815-bf56-24778cde4845",
    "userId": "f4c8f438-d0c1-703e-e0e0-d1395049be2c",
    "title": "TC017-Handle database connectivity failure gracefully",
    "description": "Verify that database connectivity issues during post creation, update, deletion, or fetch result in clear and user-friendly error messages without application crashes.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Simulate database connectivity failure to test error handling on post create, update, delete, and fetch operations.\n        frame = context.pages[-1]\n        # Click 로그인 (Login) to access user or admin features for testing post operations and simulate database failure.\n        elem = frame.locator('xpath=html/body/div[2]/header/div/div/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Simulate database connectivity failure by triggering the Kakao login button to test error handling in the InAppBrowserWarning component.\n        frame = context.pages[-1]\n        # Click the Kakao login button to simulate database connectivity failure and trigger InAppBrowserWarning component logic.\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Simulate database connectivity failure by triggering an API failure or mock failure, then attempt createPost operation to verify error handling and user-friendly error message.\n        await page.goto('http://localhost:3000/admin', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Navigate back to home page to find accessible UI or API endpoints to simulate database failure and test post operations error handling.\n        frame = context.pages[-1]\n        # Click '← 홈으로 돌아가기' to return to the home page for further testing.\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Scroll down to find UI elements or links related to post creation, update, deletion, or fetching to test error handling on database connectivity failure.\n        await page.mouse.wheel(0, 600)\n        \n\n        # -> Click on '커뮤니티' (Community) link to access posts and test database failure handling on post operations.\n        frame = context.pages[-1]\n        # Click '커뮤니티' link to navigate to community posts for testing post operations error handling.\n        elem = frame.locator('xpath=html/body/div[2]/header/div/nav/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on '첫 글 쓰러 가기' (Write First Post) link to attempt creating a post and test error handling on database connectivity failure.\n        frame = context.pages[-1]\n        # Click '첫 글 쓰러 가기' link to navigate to post creation page for testing createPost operation error handling.\n        elem = frame.locator('xpath=html/body/div[2]/main/div[3]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click the '로그인 하러 가기' button to navigate to the login page and perform login to enable post operations testing.\n        frame = context.pages[-1]\n        # Click '로그인 하러 가기' button to navigate to login page for authentication.\n        elem = frame.locator('xpath=html/body/div[2]/main/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click the Kakao login button to perform login and proceed with post operations testing under simulated database failure.\n        frame = context.pages[-1]\n        # Click the Kakao login button to perform login and proceed with post operations testing.\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input test credentials into ID and password fields and click 로그인 button to attempt login and proceed with post operations testing.\n        frame = context.pages[-1]\n        # Input test user ID/email into Kakao login ID field.\n        elem = frame.locator('xpath=html/body/div/div/div/main/article/div/div/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('testuser@example.com')\n        \n\n        # -> Clear the ID input field to remove unexpected UI or popup, then re-input the test user ID and password, and attempt login again.\n        frame = context.pages[-1]\n        # Click the clear input button to clear the ID field and remove unexpected UI or popup.\n        elem = frame.locator('xpath=html/body/div/div/div/main/article/div/div/form/div/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input test user ID and password into the respective fields and click 로그인 button to attempt login and proceed with post operations testing.\n        frame = context.pages[-1]\n        # Input test user ID/email into Kakao login ID field.\n        elem = frame.locator('xpath=html/body/div/div/div/main/article/div/div/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('testuser@example.com')\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Database connection successful').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test failed: Database connectivity issues during post operations did not show user-friendly error messages, indicating a failure in error handling as per the test plan.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The task to verify that database connectivity issues during post creation, update, deletion, or fetch result in clear and user-friendly error messages without application crashes is incomplete. We reached the Kakao login page and attempted to input credentials, but an unexpected UI behavior prevented successful login. Without login, we could not perform post operations to simulate database failure and verify error handling. Therefore, no post operation error messages were observed or validated. Further testing requires resolving login input issues or alternative authentication methods to proceed with post operations testing under simulated database failure.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 404 (Not Found) (at http://localhost:3000/admin:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/f4c8f438-d0c1-703e-e0e0-d1395049be2c/1768807248138076//tmp/test_task/result.webm",
    "created": "2026-01-19T07:15:19.734Z",
    "modified": "2026-01-19T07:20:48.319Z"
  }
]
